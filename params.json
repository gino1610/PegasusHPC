{"name":"Pegasushpc","tagline":"PegasusHPC is a High Performance Crawler","body":"<a href=\"http://1.bp.blogspot.com/-5vHYFRBU_Pc/UVICVXlbyUI/AAAAAAAAEKM/v4RE27FcUlA/s1600/g.png\" imageanchor=\"1\" style=\"clear: left; float: left; margin-bottom: 1em; margin-right: 1em;\"><img border=\"0\" height=\"151\" src=\"http://1.bp.blogspot.com/-5vHYFRBU_Pc/UVICVXlbyUI/AAAAAAAAEKM/v4RE27FcUlA/s200/g.png\" width=\"165\" /></a>\r\nI got vacations last Friday and decided to have fun with parallel computing &amp; networking.<br />\r\n<br />\r\n<h3>\r\n<b>Introduction</b></h3>\r\n<div style=\"text-align: justify;\">\r\nI wrote a framework that I called \"<a href=\"http://pegasushpc.googlecode.com/\">PegasusHPC is a High Performance Crawler</a>\", which is a web spider aimed at allowing high performance and scalability. I chose the image on the left as a tribute to <a href=\"http://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html\">pinkie pie</a>, who found critical &amp; amusing bugs in the chromium project.</div>\r\n<div style=\"text-align: justify;\">\r\n<br /></div>\r\n<div style=\"text-align: justify;\">\r\nI think this framework will be useful for me and potentially to other people, since this kind of tools happen to be useful for security testing purposes and other web related ones. It's been open source released and you can find both the first <a href=\"https://code.google.com/p/pegasushpc/downloads/list\">beta release</a> and the <a href=\"https://code.google.com/p/pegasushpc/source/checkout\">code</a>&nbsp;in its <a href=\"http://pegasushpc.googlecode.com/\">web site</a>.</div>\r\n<br />\r\n<h3>\r\n<b>Implementation</b></h3>\r\n<div style=\"text-align: justify;\">\r\nTo achieve the previous goal, I implemented in PegasusHPC a producer-consumer paradigm,&nbsp;linked blocking queues, hashsets and a master-worker approach in java to allow a natural massive parallelization of the problem.</div>\r\n<div style=\"text-align: justify;\">\r\n<br /></div>\r\nIn <i>Figure 1</i>, I show a basic high level architecture diagram of PegasusHPC.<br />\r\n<br />\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n<a href=\"http://3.bp.blogspot.com/-sRqe5ldrRRY/UVIHqys0nGI/AAAAAAAAEKU/8L2bmyswHZI/s1600/24z9hco.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://3.bp.blogspot.com/-sRqe5ldrRRY/UVIHqys0nGI/AAAAAAAAEKU/8L2bmyswHZI/s1600/24z9hco.png\" width=\"530\" /></a></div>\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n<b>Figure 1</b>. PegasusHPC Architecture Diagram.</div>\r\n<div class=\"separator\" style=\"clear: both; text-align: left;\">\r\n<br /></div>\r\n<div class=\"separator\" style=\"clear: both; text-align: justify;\">\r\nIn this approach, the Dispatcher is in charge of creating, handling and stopping the workers. On the other hand, each worker is executed in a different thread to minimize networking I/O idle time. Its implementation has been released with GPLv3 license and can the con can be found in its <a href=\"https://code.google.com/p/pegasushpc/source/browse/\">codebase</a>.</div>\r\n<div class=\"separator\" style=\"clear: both; text-align: justify;\">\r\n<br /></div>\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n<a href=\"http://2.bp.blogspot.com/-nDy2P0fDoxU/UVKkdu1olAI/AAAAAAAAEK8/7f2WzL8YmqU/s1600/ui.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://2.bp.blogspot.com/-nDy2P0fDoxU/UVKkdu1olAI/AAAAAAAAEK8/7f2WzL8YmqU/s1600/ui.png\" width=\"550\" /></a></div>\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n</div>\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n<b>Figure 2</b>. PegasusHPC User Interface.</div>\r\n<div>\r\n<div style=\"text-align: center;\">\r\n<br /></div>\r\n</div>\r\n<div class=\"separator\" style=\"clear: both;\">\r\nIn <i>Figure 2 </i>we show its user interface, the current supported options are:</div>\r\n<ul>\r\n<b>-t {target}</b> Complete URI of the targeted host i.e. <a href=\"http://google.com/\">http://google.com</a><br />\r\n<b>-nt</b> <b>{#threads}</b> Number of threads to create. Suggested between 500-10000.<br />\r\n<b>-max</b> <b>{#URIs}</b> Number of unique URIs to crawl.<br />\r\n<b>-ipBased</b> to follow links to different domain of the same server.<br />\r\n<b>-domainBased</b>&nbsp;to target a specific host or path<b><br class=\"Apple-interchange-newline\" />-h</b>&nbsp;print the help menu<br />\r\n</ul>\r\nTherefore, a common execution will look like <i>$java -Xmx4000m -jar pegaushpc.jar -t <a href=\"http://youtube.com/\">http://youtube.com/</a> -nt 1000 -ipBased -max 10000</i><br />\r\n<i><br /></i>\r\n<br />\r\n<h3>\r\n<b>Experimentation Results</b></h3>\r\nIn order to benchmarking the scalability of PegasusHPC, we carried out some experiments. The environment was the following one:<br />\r\n<ul>\r\n<li>Machine: Laptop i7 8GB ram.</li>\r\n<li>Bandwidth: 100mbps</li>\r\n<li>Target: http://microsoft.com</li>\r\n<li>Max URls: 50000</li>\r\n<li>#Worker Threads: 1024</li>\r\n</ul>\r\n<br />\r\nAs a result of the previous test, PegasusHPC wrote two files, the one with the results and a log file with the trace as:\r\n<br />\r\n<pre class=\"brush: java\">2 [main] INFO Target - protocol [http] host[microsoft.com] port[80] path[/]\r\n\r\n4 [main] INFO Pegasus  - Targeting [http://microsoft.com/] with [1024]threads and stopping at[50000] results and targetting all subdomains\r\n\r\n190 [main] INFO Dispatcher - [OK]Pool of 1024 threads successfully created, party started\r\n\r\n192 [main] INFO Dispatcher - [OK]Current unique URIs[1] max urls[50000] idle threads [false] URIs queued [0].\r\n\r\n4193 [main] INFO Dispatcher - [OK]Current unique URIs[15] max urls[50000] idle threads [false] URIs queued [0].\r\n\r\n6194 [main] INFO Dispatcher - [OK]Current unique URIs[170] max urls[50000] idle threads [false] URIs queued [0].\r\n...\r\n193361 [main] INFO Dispatcher - [OK]Current unique URIs[50019] max urls[50000] idle threads [false] URIs queued [66012].\r\n\r\n193361 [main] INFO Dispatcher - Results reached, stopping\r\n\r\n193371 [main] INFO DataStats - took [193]secs\r\n\r\n193372 [main] INFO DataStats - Analyzed [50019] unique pages\r\n\r\n193373 [main] INFO DataStats - Found [116031] unique pages\r\n</pre>\r\n<br />\r\nI made a simple script to parse the previous log file and allow gnuplot to easily get the data.<br />\r\n<pre class=\"brush: bash\">cut -d ' ' -f2- log.out  | grep Current |awk '{print $7 $9 $15}' | sed -e \"s/URIs\\\\[//g\" | sed -e \"s/\\\\]urls\\\\[/ /g\" |$sed -e \"s/\\\\]\\\\[/ /g\" | sed -e \"s/\\\\].//g\" &gt; clean.res\r\n</pre>\r\n<br />\r\nThe gnuplot script I developed for the graph is the following one:\r\n<br />\r\n<pre class=\"brush: bash\">set title \"Target: http://microsoft.com/, Threads: 1024\"\r\nset terminal png\r\nset output \"plot.png\"\r\nset style data linespoints\r\nset xlabel \"Execution Time (seconds)\"\r\nset xrange [1:193]\r\nset ylabel \"Unique #URIs\"\r\nset yrange [1:80000]\r\nset key left box\r\nplot \"clean.res\" using 1 with linespoints ls 1 title \"Analyzed URIs\", \"clean.res\" using 3 with linespoints title \"Queued URIs\"\r\n</pre>\r\n<br />\r\nThe chart that got generated as a result of the previous script running on the cleaned log file is shown in <i>Figure 3</i>.\r\n<br />\r\n<br />\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n<a href=\"http://4.bp.blogspot.com/--r-jOmf4Rvs/UVJCK2_MGiI/AAAAAAAAEKo/hPNVZWQ7rE0/s1600/test.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://4.bp.blogspot.com/--r-jOmf4Rvs/UVJCK2_MGiI/AAAAAAAAEKo/hPNVZWQ7rE0/s1600/test.png\" width=\"95%\" /></a></div>\r\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\r\n<b>Figure 3</b>. PegasusHPC URIs Found per Second.</div>\r\n<br />\r\n<div style=\"text-align: justify;\">\r\nIf we do a simple computation of the previous numbers, we got an average Analysis ratio of <b>259 URIs/second</b> and an average unique URI finding ratio of <b>601 URIs/second</b>, which is not bad for a not so powerful laptop machine. More experiments will be carried out soon.</div>\r\n<div class=\"separator\" style=\"clear: both; text-align: justify;\">\r\n<i><br /></i></div>\r\n<div class=\"separator\" style=\"clear: both;\">\r\n<i><br /></i></div>\r\n<div class=\"separator\" style=\"clear: both;\">\r\n<i><br /></i></div>\r\n<div class=\"separator\" style=\"clear: both;\">\r\n<i><br /></i></div>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}